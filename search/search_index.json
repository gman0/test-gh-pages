{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KCP contrib contents","text":"<p>The repository contains the list of demo code, slides and other materials used in the meetups, conferences.</p> <ul> <li>Platform Engineering Day EU 2024 - Building a Platform Engineering API Layer with kcp<ul> <li>YouTube</li> <li>Slides</li> </ul> </li> <li>KCP ML shop - KCP Service owner, provider and user demo. <ul> <li>YouTube</li> <li>Slides</li> </ul> </li> <li>KubeCon'24 Salt Lake City, US -  Deep Dive Into Generic Control Planes and kcp<ul> <li>YouTube</li> <li>Slides</li> <li>Demo</li> </ul> </li> </ul>"},{"location":"#other-content","title":"Other content","text":"<ul> <li>KubeCon 2024 - Paris - Why Kubernetes Is Inappropriate for Platforms and How to Make It Better (video)</li> <li>KubeCon EU 2021: Kubernetes as the Hybrid Cloud Control Plane Keynote - Clayton Coleman (video)</li> <li>OpenShift Commons: Kubernetes as the Control Plane for the Hybrid Cloud - Clayton Coleman (video)</li> <li>TGI Kubernetes 157: Exploring kcp: apiserver without Kubernetes</li> <li>K8s SIG Architecture meeting discussing kcp - June 29, 2021</li> <li>Let's Learn kcp - A minimal Kubernetes API server with Saiyam Pathak - July 7, 2021</li> </ul>"},{"location":"Learning/","title":"Learning","text":"<p>Collection of learning material from kcp demo sessions.</p> <p>Session breakout for Kubecon 2025 London</p> <ul> <li>Workshop: Exploring Multi-Tenant Kubernetes APIs and Controllers with kcp</li> <li>Talk: bla, ble</li> </ul>"},{"location":"Learning/20240321-kubecon-paris/","title":"KCP ML Shop demo","text":"<p>This is a demo of a simple machine-learning service, hosted on KCP. It shows how to use the KCP as a platform to deploy a  machine-learning model and expose it as a REST API. Use global shards to run models close to data (geo placement).</p> <p>Demo recording: https://youtu.be/7op_r9R0fCo?si=8KxUnEgSASBRJCFG&amp;t=1515 </p>"},{"location":"Learning/20240321-kubecon-paris/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>KCP running with shards - shards <code>root</code> and <code>beta</code> are required. </li> <li>See KCP sharded helm example</li> <li>Kubectl installed</li> <li>Kubectl-workspace plugin installed</li> </ul>"},{"location":"Learning/20240321-kubecon-paris/#demo-scenario","title":"Demo scenario","text":""},{"location":"Learning/20240321-kubecon-paris/#platform-operator-persona","title":"Platform operator persona","text":"<p>The platform operator is responsible for setting up the platform and enabling 3rd party. This is done by creating APIExports and APIBindings in dedicated workspace. Workspace management is done via <code>kubectl-workspace</code> plugin.</p> <pre><code>export KUBECONFIG=kcp.kubeconfig\n</code></pre> <ol> <li>Show current \"platform backend\" view:</li> </ol> <pre><code>k ws tree\n</code></pre> <ol> <li>Bootstrap the assets. This shows the platforms provider enabling 3rd party to handle the management of certain resources via APIBindings:</li> </ol> <pre><code>go run ./cmd/controller/ init --kubeconfig=kcp.kubeconfig\nk ws tree\n</code></pre> <ol> <li>Show what server side looks like:</li> </ol> <pre><code>k ws use root:ml:training\nk get apiexports\nk get apiexport -o yaml\n</code></pre> <p>Now that a platform owner has pre-created assets, and 3rd party can use them to deploy models, let us move to service provider persona. </p> <p>Important: In the demo we used the same <code>kcp.kubeconfig</code> for both platform operator and service provider. In real-world scenario, those would be different kubeconfigs, preferably generated by the platform operator and certificate-based. </p>"},{"location":"Learning/20240321-kubecon-paris/#service-provider-persona","title":"Service provider persona","text":"<ol> <li>The service provider has a controller to run pointing to this APIExport:</li> </ol> <pre><code>export KUBECONFIG=idp.kubeconfig\n</code></pre> <p>Important: Mount code is not yet open-sourced and it's a work in progress. The cluster running the controller has to have access to both APIExport exported URLs, showed in the previous step. In a real-world scenario, this would be done via VPN or other secure means, where shards can be accessed.</p> <ol> <li>Deploy the controller:</li> </ol> <pre><code>k apply -f ../kcp-ml-shop/demo/deploy/namespace.yaml\nk create secret generic kubeconfig --from-file=kcp.kubeconfig -n ml\nk apply -f ../kcp-ml-shop/demo/deploy/deploy.yaml\n</code></pre>"},{"location":"Learning/20240321-kubecon-paris/#user-persona","title":"User persona","text":"<ol> <li>User has a model to deploy - Create an ML-enabled workspace (in 2 locations):</li> </ol> <pre><code>k ws create ml-europe --location-selector=name=root --type ml-training\nk ws create ml-us --location-selector=name=beta --type ml-training\n</code></pre> <ol> <li>Deploy the model</li> </ol> <pre><code>cat demo/model.yaml\nk ws use ml-europe\nk create -f demo/model.yaml\n# get to US:\nk ws use ..\nk ws use ml-us\nk create -f demo/model.yaml\n</code></pre>"}]}